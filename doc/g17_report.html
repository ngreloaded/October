<html><head><title>Lab09 Report</title><link rel="stylesheet" href="./style.css"></head> <body><br><br><br><div>
<br><h1>Project Report for CS296 <br> Cheetah Simulation <br> Group 17</h1>
<div class="author"><b>By:</b><br><br>Naveen Sagar<br>120050026 ,
 <span style="font-family:monospace">120050026@cse.iitb.ac.in</span style="font-family:monospace"> <br>
<br>
Aditya Kumar Akash<br>120050046 , <span style="font-family:monospace">adityaakash@cse.iitb.ac.in</span style="font-family:monospace"> <br> 
<br>
Prateek Chandan<br>120050042 , <span style="font-family:monospace">prateekchandan@cse.iitb.ac.in</span style="font-family:monospace"> <br>
<br><date>05/10/2014</date>
</div> 
<br><br>
<br><h2>Indroduction</h2>
This document gives details of the Project report for the course CS296 Software Systems Laboratory, taken by Prof Parag Chaudhary\cite{sir}. 
<br>It contains The details of the new cheetah simulation.Cheetah is the fastest running animal on the planet.In out Box2D simulation project we have tried to model the simulation of cheetah's body , its balancing along with it's basic motion like walk and jump <br>
<h2>The Aniamtion</h2>
<br><h3>Model submitted in abstract</h3>
The model submitted in the project proposal was : <br>
Each legs has three moving parts connected to a hinge which is shown in the diagram. They can rotate and give motion to the model. Also the rib , tail and the neck of the model is made of small polygons which can swing and maitain the body of the cheetah.
<br><div class="image">
	<img src="drawing.png" alt="drawing.png">
		<div class="img-caption">The model submitted in abstract</div class="img-caption">
</div class="image">
<h3>Final Box2d Model of the Cheetah</h3>
The model submitted in the project proposal was : <br>
Each legs has three moving parts connected to a hinge which is shown in the diagram. They can rotate and give motion to the model. Also the rib , tail and the neck of the model is made of small polygons which can swing and maitain the body of the cheetah.
<br><div class="image">
	<img src="final.png" alt="final.png">
		<div class="img-caption">The completed model in Box2D</div class="img-caption">
</div class="image">
<h3>Deviation from the design</h3>
<b>Removals</b>
The part which is missed in the final design in the rib of the cheetah. The main reason to remove it was the balancing problem of the cheetah. As due to the changed and different body parts , a firm center part was required
<b>Additions</b>
Wee added the muscles to the leg of the cheetah making the balancing of the cheetah to be more realistic and also we added Theo Jansen\cite{jansen} Walking mechanism for Cheetah which is a wheel based walking mechanism
<br><h2>Physics behind the simulation and details of the mechanism used</h2>
This section contains information about the different parts of cheetas body which is used in the animation
<ul>
	  <li> Walking Mechanism
</li>	  <li> The legs and Muscles
</li>   	 <li> The Tail
</li>     <li> Neck and Head
</li>     <li> Main body
</li></ul>
<h3>Walking Mechanism</h3>
The Walking Mechanism of cheetah is based on Theo Jansesn\cite{jansen} walking mechanism
<br><b>Theo Jansen linkage</b>
It is a “crank-based” where the circular movement of
one point in the linkage translates to movement elsewhere in the linkage; this means the
circularly moving part of the li
nkage can be attached to a crank so that the motion of the
mechanism is easily driven allowing easy locomotion
<br><b></b>
<div class="image">
    <img src="jansen.png" alt="jansen.png">
        <div class="img-caption">The image showing Walking Mechanism</div class="img-caption">
</div class="image">
<br><br><h3>The legs and Muscles</h3>
<b>Description of Leg</b>
There are 4 legs in total of the cheetah two in the front while two in the back. Each of the leg consists of two bony parts joined by the revolute joints with constraint in  the angle of rotation so as to maintain the shape of the leg<br>
These legs are then joined by the theo jansen walking mechanism
<b>Distance Joints as Muscles</b>
The walking mechanism is joined by distance joint which acts as springs which act as shock absorber for cheetah. It also helps in balancing of the body and legs after few deformations
<br><b></b>
<div class="image">
    <img src="joint.png" alt="joint.png">
        <div class="img-caption">The image showing Distance joints as muscles</div class="img-caption">
</div class="image">
<br><h3>The Tail</h3>
<b></b> 
This part is cheetah's tail which consists of multiple small blocks joined together with revolute joints.The revolute joint in the tail is constrained with the the angle constaints . Total sum of constraint in the allows it to move totally while maintaining its initial shape. Since tail is the highly important in maintaining the body balance its weight is accurately set so that it gives proper motion to body
<br><br>
Each of the block itself is made of two rectangular blocks joined together
<br><br>Due to the tail the angular mometum of the cheetah's body is balanced
<div class="image">
    <img src="tail.png" alt="tail.png">
        <div class="img-caption">The image of tail consisting of multiple joints</div class="img-caption">
</div class="image">
<h3>Head and the Neck</h3>
<b></b> 
The head of the cheetah is a normal body mady of a convex polygon.While the neck is far more interesting. Thr neck consists of three blockes joined and packed closely with a revolute joint. This helps in the swingning motion of the neck of the cheetah.
<br>
<div class="image">
    <img src="head.png" alt="head.png">
        <div class="img-caption">The neck and head of cheetah</div class="img-caption">
</div class="image">
<h3>Main body of cheetah</h3>
<b></b> 
The main body of cheetah consists of a wide rectangular box to which all other parts of cheetah is joined. It acts a support for the whole body and helps in controlling the mwalking and jumping mechanism of cheetah.
<br>The walking mechanism is at the center of this body and it controls whole of the walking of the cheetah
<br><h2>What makes the Simulation Interesting</h2>
<br>The cheetah is the fastest land animal, achieving a top speed of about 70 mph (113 kph)\cite{facts} This is the main motivation toward taking up of this project. But owing the the restrictions of Box2D we tried to stimulate some of the parts of Cheetah's body and balancing and other details. Making a prototype of Living Organism which is the most complex machines makes our simulation interesting<br>
<br><br>While running the simulation you can see the swift swinging motion of tail, the motion of the head. Make the cheetah jum high and then land it to the ground. You can see the detailing of the landing and balancing. Such things also make the simulation interesting
<h2>Profiling report of the code </h2>
<b></b>
Using the profiling technique used in Lab09 we profiled the simulation of cheetah to find out the results
 
 <i>We have used perf profiler to make the profile data.</i><br>
 <i>No of iteration for data : 10000</i>
<br><h3>Call Graphs</h3>
A call graph is a directed graph that represents calling relationships between subroutines in a computer program.
Specifically, each node represents a procedure and each edge indicates that procedure f calls procedure g.<br>
<br><b>Generation of call graph using perf and the gprof2dot.py</b> <br>
<code>
perf record -g -- ./mybins/cs296_17_exe
perf report > g17_release_prof.dat
perf script | python gprof2dot.py -f perf | dot -Tpng -o release.png
</code>
<br><div class="image">
	<img src="debug.png" alt="debug.png">
		<div class="img-caption">Debug Call Graph</div class="img-caption">
</div class="image">
<br><h3>Observation from Debug Call Graph</h3>
List of Functions which consume most time in the call of their parents
<ul>
    <li> b2World::step() 92.00 %
</li>    <li> b2World::solve() 49.00 %
</li>    <li> b2RevoluteJoint::SolveVelocityConstraints() 8.00 %
</li>    <li> b2DistanceJoint::SolveVelocityConstraints() 9.24 %
</li>    <li> b2weldJoint::SolveVelocityConstraints() 9.24 %
</li>    <li> b2Fixture::SynchronizeFixture() 21.29 %
</li>    <li> b2Fixture::Synchronize() 20.00 %
</li>    <li> b2BroadPhase::MoveProxy() 11.00 %
</li>    <li> b2BroadPhase::UpdatePairs(b2ConstactManager) 9.56 %
</li>    <li> b2DynamicTree::querry() 7.24 %
</li>    
</ul>
<br><div class="image">
	<img src="release.png" alt="release.png">
			<div class="img-caption">Release Call Graphs</div class="img-caption">
</div class="image">
<br><h3>Observation from Release Call Graph</h3>
List of Functions which consume most time
<ul>
    <li> b2RevoluteJoint::SolveVelocityConstraints() 4.76 %
</li>    <li> b2DistanceJoint::SolveVelocityConstraints() 4.48 %
</li>    <li> b2weldJoint::SolveVelocityConstraints() 3.92 %
</li>    <li> solve() 5.20 %
</li>    <li> b2Timer::GetMilliseconds() 3.86 %
</li>    <li> b2DynamicTree::Querry() 6.74 %
</li>    <li> b2Fixture::synchronize() 0.80 %
</li></ul>
<br><h3>Analysis of above Call Graphs</h3>
<b>General Analysis</b> :<br>
<b>Debug Mode</b> :<br>
As we can see from the callgraph and the most time consuming functions , debug mode calls much more functions as compared to the call graph of release mode.
Most of the time is consumed by the calculating functions which are solve , solveVelocityContraints etc 
consumes most of the time as compared to the Drawshape funstion and drawDebug function<br>
<b>Release Mode</b> :<br>
As opposed to the times in Debug mode , The Drawshape function take the most time in the running of the function while the solving function functions like
solveVelocityContraints and solve function took time much lesser than that in debug mode. also the system library used for calculation took very less
time <br>
<b>Special Analysis w.r.t The Project Code </b> : <br>
Clearly we can see that the functions related to synchronizing fixtures and collision detection such as - <i>SynchronizeFixture() and FindNew Manager</i>
take more as compared to profiling done in earlier labs.<br>
Also the Functions related to BroadPhase which manages the proxies ( - representing the AABB's in broadPhase collision algorithm ) 
and the creation and deletion of records w.r.t the overlap of proxies such as
<i>MoveProxy(), UpdatePair(), InsertLeaf(), Querry()</i> take much time as compared to previous profiling. <br>
Moreover the functions ( SolveVelocityConstraints() )  related to solving the constraints equations for the joints - <i>Revolute, Weld and Distance</i> take more time in comparision.
<br><br><h3>Inference from the above Analysis</h3>
<br><b>General Inference</b>
We can clearly see that the Debug mode is taking more time for all the functions in comparision to the release mode which does the optimization.<br>
The function <i>solveVelocityConstraint()</i> and <i>solveVelocityConstraint()</i> takes more time in both the modes.
The step function is taking a lot of time in the debug mode as it is the function which is called again and again. <br>
The <i>DrawShape()</i> takes significant amount of time as this function is called each time the <i>DrawShape()</i> function is called.
This function is responsible for updating the position of the various objects on the frame after the solving of all velocity and position 
constraint equation is solved. So it is natural for this function to take more time. <br>
The library _mcount takes more time in the debug mode but negligible amount in release mode and hence no need to optimize thus library.<br>
<br><b>Special Inference wrt Project Objects</b>
We can clearly see that the program spends a lot of time in handling the different fixtures.
The functions which are responsible for obtaining the overlap of fixture proxies - ( the AABB's representation ) and storage
of these in a dynamic tree consumes lot of time. 
The behaviour is justified since we have a lot of fixtures which are overlapping and many of them are using collision filtering
using <i>filter.groupIndex</i> . Thus the box2d engine has to spend a lot time to decide which of them to collide and which not.
Moreover we have 2 bodies - <b>tail, neck</b> which is made of lot of smaller bodies joined together and spaced very close to each other .
Thus the contact equations are to be solved more often for the fixtures of these bodies.
Also due to lot of smaller bodies connected to form larger bodies we get a lot of joints of all kinds. Hence the constaint equations for 
these joints are solved more often thus explaining the cause that SolverVelocityConstraints() of these joints take a large time.
<br><h3>Optimizations Required</h3>
Refering to the above Inference we see that we would have to decrease the number of pieces that makes the tails and the neck. 
But such a process would result in destroying the flexible movement of the tail and neck and thus changing the expected behaviour.
So we changed the spacing and arragement of the object in neck . Also for tail the fact that we could initialize the same body with
different fixtures was used to decrease the number of bodies actually making the tail .<br>
For different fixtures that were using the groupIndex to do collision filtering we tried to expolit the fact we used for tail.
But the mass distribution which maitained the overall balance of the cheetah on its legs and helped the crank system to make it move smoothly
got unbalanced cauising some unexplained behaviour . Hence we had to compromise in this optimization by designing the bodies so that balance 
is also maintained and the overlapping parts overlap as less as aloowed so that the movement is smooth. 
<br><h2>Analysis Report for the plots my Matplotlib</h2>
This section contains the Reports , Obsevations and Inference from the timing diagram which are obtained from the data and the 
Plots generated using matplotlib of the project simulation.<br>
No of Iteration for which the 	the iteration was run for 1 to 500 and 50 rerun for each iteration
<h3>Observation from Plot1</h3>
The following inference were drawn from the Plot1 diagram which was Plot of Average Step time  and Average loop time:
<ul>
    <li> The Average loop time is greater than the Average Step Time but is almost equal
</li>    <li> The average time for the decreases as the no of iteration increases
</li></ul>
<b>Explanation:</b>
Since for the first few iterations the world is being set and all the objects in a state of movement to get settled to there stable state
and also the no of of collisions taking place are too high, the time taken by the Loop in fisrt few Interation are High.
But as he loop progresses the animation gradually takes place without much calcualtion or updates and the updates are very few so the time for 
the further loops decreases. Due to this the average time for more iterations decreases as compared o lesser no of Iterations<br>
<br>Since the step time is the of all times taken by the loop while the loop time is the total time taken by the loop in addition to the Time 
taken by system processes so the loop time is slightly greater than the step time. And when the same was generated while the sytem was overloaded 
with programs, This gap was still greater.
<div class="image">
		<div class="img-caption">Plot1</div class="img-caption">
<img src="../plots/g17_plot01.png" alt="../plots/g17_plot01.png">
</div class="image">
<h3>Observation from Plot2</h3>
The following inference were drawn from the Plot2 diagram which was Plot of Step time , Collision time , Velocity update time , Position update time
and sum of last 3 averaged:
<ul>
    <li> The step time is greater than the sum of Collision time , velocity update time and position update time
</li>    <li> All of these times decreases as the no of iteration increases
</li></ul>
<b>Explanation:</b>
The step time is the time taken by the loop which is running the Animation. But the other three times are exactly what they are meant to be.
But since the step time is the time taken by all of the things within a loop , So there are other processes which will also be called within the for loop 
and they will take time increasing the step tme<br>
<br>The explnation for initial times to be greater as the explanation in of Plot1
<div class="image">
		<div class="img-caption">Plot2</div class="img-caption">
<img src="../plots/g17_plot02.png" alt="../plots/g17_plot02.png">
</div class="image">
<h3>Observation from Plot3</h3>
The plot3 was the plot of averaged step time along with error bars calculated with standard deviation<br>
<br>It is observed that the error bars for the average stem time for lower no of iterations was too high as compared to the error
 bar for higher no of iterations <br>
 
This might be because of the reasons explained in Plot1. Since the setting of world can take place differently for only one iteration because of 
setting up of worlds and setting up of initial position of objects so the error bar is too high. But when the no of iteration is high, This total 
time sums up to almost be equal. So the standard deviation is low making the error bar to be small. 
<div class="image">
		<div class="img-caption">Plot3</div class="img-caption">
<img src="../plots/g17_plot03.png" alt="../plots/g17_plot03.png">
</div class="image">
<h3>Observation from Plot4</h3>
When the step time gets averaged up it keeps fluctuating around the the average value which comes out to be 
0.94 second and the rest of the times are around it.<br>
<br>But there is an Outlier time which denotes the time at the start of the loop. Since  At the beggining the times are higher so they 
contribute for a frequency of a higher time
<div class="image">
		<div class="img-caption">Plot4</div class="img-caption">
<img src="../plots/g17_plot04.png" alt="../plots/g17_plot04.png">
</div class="image">
<h3>Observation from Plot5</h3>
Plot 5 was the plot for the best fit line for the step time averaged over all data and step time averaged over some random data
<ul>
    <li> The points for the averaged time of all data and random data are almost equal 
</li>    <li> The best fit line comes to be almost same for both of them
</li></ul>
<b>Explanation:</b>
	Since the time for a particular iteration is almost the same so it doesnt matter much if the points are averaged over all data or 
the  points are averaged over only few random data. Due to this the points comes to be nearly the same and also the best fit line is nearly 
the same
<div class="image">
		<div class="img-caption">Plot5</div class="img-caption">
<img src="../plots/g17_plot05.png" alt="../plots/g17_plot05.png">
</div class="image">
<h2>Conclusion</h2>
<b>Project</b>
The cheetah simulation along with finishing of the project was very intersting and of great learnig experience. We learnt various aspects of complex machine simulation , different walking mechanism used by cheetah , Implementation in box2D with a simpler walking mechanism , simulating body parts like tail and neck of the cheetah and other things. The amount of learning experience from this project was too great.
<b>CS296 course</b>
This CS296 was overall a great learning ecperience of Box2D and also other software development techniques. In the CS296 course as a whole we learnt a lot and we are very thankful to the instructor Prof Parag Chaudhary\cite{sir}. The software development techniques learnt and the other very usefull softwares learnt has increased <i>sir</i> in us. And we will continue our the Coding aspect followed up from this course.
<br><br><br><br></div>
<br><footer>Project made as a part of CS296 Lab IIT Bombay<div class='link'><a target=_blank href='http://www.cse.iitb.ac.in/~prateekchandan/cs296' >Link to the Project Webpage</a></div></footer></body></html>